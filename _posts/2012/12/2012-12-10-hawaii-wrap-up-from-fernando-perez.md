---
title: Hawaii Wrap-Up from Fernando Perez
author: Greg Wilson
permalink: /2012/12/hawaii-wrap-up-from-fernando-perez/
categories:
  - Reports
  - Teaching
---
[guest-posted by Greg Wilson]

Overall it went well but obviously with some glitches, as always. People seemed excited, though, and had plenty of questions and energy. So I think the main point, which in my mind is to show them this stuff is valuable and not as hard as they think, was achieved. You can't really *teach* all that much in two days of firehose flooding, so my hope is instead to leave an audience motivated enough to continue trying to learn for real on their own later on. I think if you really want to teach solid, lasting skills, something more along the lines of a week-long summer school is really necessary.

I went a little off-script regarding the classic SWC approach, and did two things at the beginning of the Python session that aren't normally part of SWC but which John Hunter and I always did in our workshops and we found worked well:

1.  A fast, high-level overview of 'python for science' with catchy examples: John Hunter's epliepsy ECOG work that led to matplotlib and ends with the famous Phoenix Mars lander bug story (always a crowd pleaser), then tying the astronomy theme with Josh Bloom's work on the discovery of the 'supernova of a generation' in summer 2011, and finishing with the 'IPython for the lifecycle of a scientific idea' supported by demonstrations of the various moving parts. The feedback I got was that people liked it a lot because it gave them a sense that these tools were really worth learning, even if they weren't at that skill level right off the bat.
2.  I did a 'typealong' example where we downloaded by hand a financial dataset from Yahoo finance, did some plotting to answer a few basic questions about a stock, then automated the process to do the downloading via urrlib so that they could rerun the whole notebook for any new stock in one shot. The point here was for them to see that, even if they were typing commands they didn't fully understand yet, that with a few lines of not-so-difficult code they could automate a non-trivial task with real-world data pulled live from the internet. Several people later said they found that very motivating because it gave them a sense that *they* could do it, by having done it on their own machine (rather than just watching someone else do a slick demo). I think it went on for a bit longer than necessary, so I need to streamline it better, but I remain convinced the idea is sound. The material is on the github repo now.

Switching to more problematic issues, here are the points I see as needing attention now:

*   The shell on Windows. Man, this is a @#%$ nightmare... The fact that on Windows there are *three* incompatible shell environments now: cmd.exe (the old-fashioned 'DOS prompt'), the new PowerShell (which tools like Github for Windows now use) and the cygwin Bash, is a bloody mess. You can try to focus on teaching cross-platform 'classic unix' skills via bash, but the abstraction has a Titanic iceberg-sized leak: half the things you do on *nix with bash really call out to other unix tools, which aren't there unless you go all out and install an entire cygwin. And cygwin is it's own little weird monster with a funky installer and package manager, so it's not like telling them to do that is a painless solution either. 
    Frankly I don't know what to do there. If SWC really wants to have shell skills at an intro course where students are likely to arrive with a random mish-mash of machines that range from a beat-up 5-year old Dell running Windows XP to a brand-new retina mac, I have no idea how to do that without major pain. I know SWC wants the 'unix literacy' to be part of its core teachings, but the reality is that Microsoft has made Windows about as unfriendly to that kind of workflow as you can possibly imagine, so there will always be a lot of pain going down that road. John Hunter and I always taught only python, and what little os-related stuff was visible through IPython (cd, ls, pwd, mkdir), IPython makes pretty cross-platform, so I'd never seen this problem first-hand.
    
    Perhaps having the shell be part of a separate module, perhaps doing it only on the cloud (at least for Windows users), I don't know. But after seeing the chaos that explaining bash work creates with a mix of windows/mac/linux users, I'm not at all convinced the pain is worth the benefit.</li> 
    *   Git: while there was a ton of interest, I think the teaching materials still need work. We don't have yet a tutorial oriented towards scientists that I *really* like; I think what was on the SWC github repo had too many low-level details, so I looked around for other options. I found a 'Git for scientists' tutorial at NYU (no link right now, I'm writing this offline but it's very easy to find), and I decided to teach off that. It's a little more high level but I still was dissatisfied with the fact that it talks right off the bat too much about things like staging and the index, which honestly I think can be skipped on a first introduction to git. Emanuele Olivetti has some nice slides that he wrote for the G-Node Python workshops in Europe, I'mm going to review those more carefully and will ask him for the sources, that might be a better starting point. I have to teach a winter school in Norway in January with a 2-hour git/VC session, so I'll try to improve this part and will be happy to contribute back any progress I make. 
        But one point that stuck was the need to tackle the configuration issue up front. Running git without having configured at least the basic user name, email and $EDITOR is a *bad idea*, as we discovered. If those three things at the very least aren't set, users immediately run into warnings, convoluted messages and getting dumped into a vim window. That's just a disaster. We need to help them out by doing the configuration first, so the initial experience is smooth. That also means dealing with an editor right away, for better or worse.
        
        I guess one option would be to look into teaching the use of 'git gui' as the entry point... That's never been my style, and I'd need to test if it works out of the box on mac/windows, but it's worth at least exploring the question... I'm not crazy about it, as I tend to prefer teaching people the base command line. But I've been playing a little bit with it and maybe it's not such a bad choice to help new users bypass the complexities of configuration, editor management and having visual feedback on the mental model of a repository and where all the moving parts are. I'm going to study this a bit more and do some testing on all platforms to see what happens.</li> 
        *   IPython notebook: went well overall, but obviously there are issues. Installation went overall pretty well, with almost everyone being able to install EPD and then run the enpkg update commands to get 0.13.1 with minimal effort. Ironically, the only challenging people I dealt with were a couple of linux users who had crazy old Ubuntu installs on badly resource-constrained VMs (not enough RAM, not enough hard disk). I was able to fix things for one of them and the other switched to working on a remote box she keeps (an Amazon instance, I think). But as far as I could tell, all the mac/windows users were just fine with EPD. 
            The more serious issue that I noticed is that even with the notebook offering a persistent view of what's being presented and making the notebooks available online, some people still fall behind simply because content scrolls off the screen. In order for people in the back to be able to read, it's necessary to enlarge the font size significantly, which means not that many lines fit on the screen to begin with. We have a way to run a notebook server in read-only mode that can be used to 'broadcast' what the instructor is typing, but whether that works or not will depend on the state of the local network and how much they let you run stuff on funky ports. The only other real alternative is for the instructor to run on a public machine (cloud or otherwise persistent system). That will make access more likely to succeed, as long as the network access is good enough. Basically it boils down to needing good connectivity, but honestly I don't think it's logically possible to solve the problem of synchronizing content in real time to an entire room if there's no way to send them the information... So perhaps we just need to bite the bullet and consider a decent network a requirement...</li> </ul> 
            OK, this is getting long enough... In summary: good outcomes, but plenty of room for improvement. what else is new <img src="http://localhost:8080/wp-includes/images/smilies/icon_smile.gif" alt=":)" class="wp-smiley" />
