---
title: 'Columbia University Recap: Part 1'
author: Erik Bray
permalink: /2012/10/columbia-university-recap-part-1/
categories:
  - Reports
---
I just returned the day before yesterday from New York, where I helped Greg run a SWC bootcamp at Columbia University, along with Chang She and Eric Weinstein.  The audience was mostly students in a data science class taught by Prof. Rachel Schutt, under the statistics department I believe.  At first I mistakenly thought most of the students to be stats students, but there were several from other backgrounds including various social sciences---didn't matter too much though, as the only statistics brought up in the few exercises we did were very basic (in that it was stuff even I know).

My role in the workshop was mainly to teach an introduction to Numpy---although this was not my first time teaching to a classroom of mostly strangers, it was my first time teaching Numpy, and there were some rough spots.  But it wasn't all bad either.  I will try to go over the good, the bad, and the ugly first focused on my own teaching, and then on the workshop as a whole (though there is some overlap).

## My Teaching

First I should mention some technical issues that came up, before getting more into my overall performance and handling of the content.  In the run up to the workshop I had prepared a sizable IPython notebook containing most of the content for my lecture (http://nbviewer.ipython.org/urls/raw.github.com/iguananaut/notebooks/master/numpy.ipynb if you're interested---the material was cobbled together from a few sources, including myself).  The notebook includes several snippets of example code that I had planned to run more or less in order while discussing the meaning of those snippets.

I had some reservations about that approach---I was particularly worried that watching me stand up there and type Shift-Enter over and over again would likely lead to rapid disengagement, and possibly move too fast.  On the first morning of the workshop I watched Greg teach Python while typing all the examples in real time.  This confirmed the reservations I had about my approach: By typing in real time it gave the students time to type in the examples themselves and keep up.  And even when Greg made mistakes in the examples it was easy to turn that around into a learning opportunity.  It also made for a much more natural flow to the tutorial, rather than my notebook that had unrelated snippets of code broken up by text.

So I made the last minute decision that I would also type the Numpy examples in live.  But I cheated, or tried to: I configured my laptop to display separate screens to the projector and to my LCD.  On the projector I showed an empty notebook, while on my screen I tried to read my notes from my original notebook.  I didn't feel like I'd had enough practice with the material to do it live without looking at my notes.  There were a few problems with this approach, some of which you can probably guess.  First of all, every couple examples I had to move my mouse from one screen to the other in order to scroll down in my notes, and the back over to the screen I was typing in.  This was awkward, and led to frequently moments of dead air filled with "ahhhh" and "ummmm".  In fact, I think switching between the screens was the source of most of the dead air for me.  Had I been able to alt-tab between the two browser windows (for some reason this wasn't working) that might have gone a little better, but not much.  By about half way through I gave up on this and started winging the examples, which I think worked better in the end.  After all, I know how to do everything I was teaching without having to think about it much, so there was no need for me to rely on copying pre-written examples verbatim.  This did lead me to do a few examples out of logical order, and some students complained about this (quite rightly) at the end.  I think that for next time I will just carry an outline of the topics (and types of examples) to cover, but make up the exact details of the examples as I go along.  I know that if I practice this a few times I won't even have to think much about the examples. After a few more teaching experiences I probably won't even need the outline.

There was one downside to abandoning my prepared notebook, and that's that it contained a few images and diagrams that would have been helpful to explain certain concepts.  There was no chalk to write on the chalkboard either, so I had to result to handwaving and paper napkins.  So I've come up with what I think (hope) will be a good compromise:  For next time I will use a prepared IPython notebook containing all the images I want to use, and *placeholder* code cells for any examples I want to make sure to do, possibly including a short comment describing what sort of example should be typed into each cell.  That way I can have my outline built into the notebook, as well as any other visuals I want to use, but it will allow me to type in the examples live.  I'll have to experiment with this format (Greg suggested videotaping myself---a dreadful thought but undeniably useful).

There was another mistake that I couldn't have remotely anticipated, but that killed me for the first several minutes of the lecture.  At the very beginning of the lecture I gave a very simple example of how much easier it is to do element-wise mathematical operations with multiple arrays using Numpy than it is using for-loops over Python lists.  I also showed how much faster the Numpy example was by using the %%timeit cell magic (new to IPython 0.13).  Most of the students, who were diligently typing in all the examples I gave them and making sure they were working, got stuck on this:  At first they were complaining that %%timeit was only evaluating the first line (Z = []).  It occurred to me that they must be using IPython 0.12 and didn't have cell magic support.  I hated the thought of just waving my hands and telling them not to think about the man behind the curtain, so I did go into a brief digression about cell magics in IPython 0.13, and that if they had an older IPython version they could still wrap the example in a function and call %timeit on it.  But that didn't work for some people either; probably because they were using the normal Python interpreter instead of IPython.  At that point, rather than get into another digression I tried to stress that I was only using %%timeit to demonstrate the runtime difference, and that it was not actually part of the Python code.

You would think this would be no big deal---that I could have just told them that I was using it for demonstration purposes and that they shouldn't worry about it.  But by the time someone complained that %%timeit wasn't working for them, several people in the class had already gotten lost and tuned out in the process of getting the example to work with %%timeit.  Even 5 to 10 minutes later, when I had moved well past it, one woman in the class---clearly exasperated---raised her hand and said that she was still getting an error about "Line magic function \`%timeit\` not found".  This was after I had already explained about %%timeit to the class twice.  This proved such a distraction that she (and probably others) were tuned out for several minutes trying to understand why the example wasn't working for them.

The first, most obvious lesson here is to avoid using magic commands or any other IPython-specific features as much as possible.  If you really have a good reason to use one, at least explain up front that this might not work for everyone depending on their Python version, and provide a simple alternative in case it does not work.  For example, I later made use of %load to pretty good effect. The people for whom it didn't work could still open the URL in their web browser and copy/paste the contents.  Also, I really shouldn't have made as much an issue about the run time performance of Numpy versus pure Python.  Instead I should have emphasized that the code was just cleaner and simpler to write---I should have emphasized the efficiency of \*coding\* with Numpy.  It's still worth mentioning better performance, but only as an aside (and using time.time()).

I need to get back to work for now, so I will post part 2 of this either tonight or tomorrow, as I still have a lot more to report.
