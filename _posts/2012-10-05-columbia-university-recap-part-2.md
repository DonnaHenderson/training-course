---
title: 'Columbia University Recap: Part 2'
author: Erik Bray
layout: post
permalink: /2012/10/columbia-university-recap-part-2/
categories:
  - Reports
---
Sorry it took me a few days to get this up&#8211;I&#8217;ve been busy playing catchup on a lot of things.

In [Part 1][1] I promised some recap of what went right/wrong in general. But first I wanted to mention one more issue that I think particularly affected my teaching experience.  Some of the (politely) critical feedback we got was that some topics and examples were clearly out of logical order. And I think that those comments were particularly targeted at the Numpy section&#8211;I knew as I was teaching it that I was getting things out of order.  Part of the problem I already mentioned: I switched over at the last minute to a live coding format and didn&#8217;t have my notes as easily accessible as I would have liked. That can be fixed for next time.  But the other problem was simply people asking questions that got ahead of what I was presenting.  In a lot of ways that&#8217;s a good thing&#8211;it means that they&#8217;re paying attention, and following along well enough to be actively anticipating what&#8217;s coming around the corner.

There were enough questions like that, however, that it started to get tedious repeating &#8220;I&#8217;m about to get to that&#8221;, and so there were a few times I jumped ahead and presented things out of order because I got tired of people asking.  In retrospect it might have been better if I stuck to my guns and stayed with the order I wanted to go in.  I just worried that people were asking in part because I was going too slowly. But I don&#8217;t want to go too fast either.

Now for some general comments&#8211;although I would like to say something about what went well, the &#8220;what went wrong&#8221; is obviously what stands out more in my mind and has been given more thought.  We had a lot of installation issues&#8211;and I&#8217;ll get to installation hell in a moment&#8211;but one thing that worked very well to alleviate the problem and keep people engaged was to have anyone who \*didn&#8217;t\* have the software installed pair up with someone who did.  By and large students were willing to do this, and while they didn&#8217;t know it at the time they were all pair programming.  As I walked around I saw them helping each other enter the Python examples that Greg was giving and correcting each other on syntax and other mistakes.  The students who got it a little faster were also very helpful.  I think by and large the level of cooperation between the students made the workshop a success.  There were several very smart people who, even despite having installation hassles, were still able to catch up.

Greg, Chang, and I agreed to ask students to install EPD Free as their Python distribution. I have a lot of complaints about EPD, but I think this worked okay for the most part.  One thing I don&#8217;t like is that on OSX at least (and probably Windows) it doesn&#8217;t create any desktop shortcuts called simply &#8220;IPython&#8221; or even &#8220;Python&#8221;.  Instead it creates a shortcut called &#8220;PyLab&#8221; which runs \`ipython &#8211;pylab\`.  Several people were confused by this and didn&#8217;t know what to run.  I also had to explain to them that &#8220;PyLab&#8221; was just ipython, and ipython is an alternate Python interpreter&#8211;which only further confused them since we never really explained clearly what a &#8220;Python interpreter&#8221; is.  I would have preferred that once we got EPD installed for people we told them to launch a terminal and run &#8220;ipython&#8221; manually, but this didn&#8217;t work for some people either.  Matt tells me that EPD issupposed to add some .profile entries so that its ipython installation is added to the user&#8217;s $PATH by default, but this didn&#8217;t seem to work for some people who I tried this with.

But EPD did work well for some people, and it meant they already got Numpy and Matplotlib without any hassles.  One other surprise with EPD is that PyLab automatically does a &#8220;from numpy import *&#8221;&#8211;since many people were running this they already had all of Numpy&#8217;s builtins available.  One of the first Python exercises Greg had them do was to average a list of integers, and many people found the &#8220;mean()&#8221; function, which they mistakenly assumed was built into Numpy.

That brings me to probably my biggest issue with the workshop, which was that in the interest of time we skipped much any discussion on the command-line shell.  I think it would have been worth spending at least a few minutes on&#8211;how to start a terminal, basic file management, and running programs.  Maybe we could have skipped searching and pipes and such for now.  But a lot of the students had simply never used the command line and were clearly intimidated by it.  This led to a lot of questions during the breaks that could really only be answered by quick shell tutorials anyways, though given in an inefficient individual basis.

For example, many students had started typing their code samples and exercises into a text editor of some sort, and were copy-pasting them into ipython.  That then led them to the obvious question: &#8220;How can I save this file and run it in Python later without having to do all this copy/pasting?&#8221;  And from there they would ask the question: &#8220;I defined some variable/function/etc in my file&#8211;now how do I get that variable into the local namespace in my interpreter?&#8221; (they didn&#8217;t use those terms, but that&#8217;s what they were groping for).  So I had to show them how to save a .py file, and how to find it and run it with Python, and later how to import it.  Importing in particular then led to discussions about &#8220;current working directories&#8221;, which was novel to some of them.  In particular, since many of them had just been launching &#8220;PyLab&#8221; from a desktop icon they had no idea what their working directory was&#8211;and indeed on different systems I saw, the default cwd was anything from their home directory, to their desktop, to C:Windowssystem32.  So in every case I ended up showing students how to launch a terminal window, cd to the directory they want to save their files to, and run python or ipython from there.  I think that at a minimum we should have taught that to the entire class.

Finally, I should mention the enormous installation hassle we had with Pandas.  And let me clarify that Pandas was **not** to blame for this.  On Windows (for which there was a binary installer), and Macs that already had a compiler it installed fine.  The problem was with Macs that didn&#8217;t already have compilers&#8211;and that was many of them.  Students had to first install XCode&#8211;a nearly 1.5 GB download&#8211;which many of them did not already have.  Then, once XCode is installed they have to install the additional ~350 MB of &#8220;command line tools&#8221; that are no longer installed by default.  Some of them understood why they had to do this, and were patient.  Others, I think, gave up.  It seemed ridiculous to have to download nearly 2 GB of additional software that they weren&#8217;t sure they&#8217;d ever use again just to run our examples.

I would have thought EPD would come with Pandas by now, but it doesn&#8217;t seem to.  If it has a binary package for Pandas we didn&#8217;t know how to install it&#8211;so one lesson is that if we&#8217;re going to continue having students use EPD we need to become more familiar with it ourselves.  The second lesson is that we simply must not rely on any software for which binary installers do not exist on Windows, OSX, and even Linux. It&#8217;s too tall an order to assume that a working compiler and development environment will be installed.

I have some further thoughts on installation hell based on what Greg and I discussed throughout the weekend.  But I can raise that issue again another time.

 [1]: http://teaching.software-carpentry.org/2012/10/01/columbia-university-recap-part-1/